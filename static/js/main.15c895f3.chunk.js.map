{"version":3,"sources":["Components/PathfindingVisualizer/Node/images/initial.png","Components/PathfindingVisualizer/Node/images/destination.png","Components/PathfindingVisualizer/Node/images/yellow.png","Components/PathfindingVisualizer/Node/images/purple.png","Components/PathfindingVisualizer/Node/images/wall.png","Components/PathfindingVisualizer/Node/images/drawwalls.gif","Components/PathfindingVisualizer/Node/images/instant.gif","Components/PathfindingVisualizer/Node/Node.jsx","Helpers/getAllNodes.js","algorithms/dijkstra.js","algorithms/depthFirstSearch.js","algorithms/breadthFirstSearch.js","algorithms/astar.js","Helpers/backTrack.js","mazegeneraionAlgo/recurssiveDivision.js","mazegeneraionAlgo/recurDivVerticalSkew.js","mazegeneraionAlgo/recurDivHorizontal.js","mazegeneraionAlgo/randomMaze.js","Components/PathfindingVisualizer/NavBar/NavBar.jsx","Components/PathfindingVisualizer/TutorialPopup/Tutorial.jsx","mazegeneraionAlgo/PrimsAlgo.js","Components/PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","this","props","row","column","onMouseDown","onMouseUp","onMouseEnter","id","key","className","e","Component","getallNodes","grid","nodes","rows","node","push","dijkstra","start_node","finish_node","distance","unvisitednodes","visitedNodeInorder","length","sortBydistance","currentNode","shift","isWall","Infinity","isVisited","updateCurrentNodeNeighbors","sort","nodeA","nodeB","neighbors","getCurrentNodeNeighbors","previousNode","filter","neighbor","depthFirstSearch","startnode","finishnode","visitedNodes","stack","pop","updateStack","breadthFirstSearch","queue","updateQueue","astar","startNode","finishNode","openlist","closedlist","f","sortOpenlistByFvalue","includes","tentativedistance","updateWithHeuristicAndF","h","Math","abs","getNodesInShortestPathOrder","nodesInShortestPathOrder","unshift","recursiveDivisionMaze","rowStart","rowEnd","colStart","colEnd","orientation","surroundingWalls","visitednodes","start","end","possibleRows","i","possibleCols","randomRowIndex","floor","random","randomColIndex","currentRow","colRandom","currentCol","rowRandom","recurssiveVerticalSkew","recurssiveHorizontalSkew","randomMaze","visitednode","counter","randomIndex","NavBar","state","is_running","setState","clearGrid","clearPath","bfs","dfs","recurDivMaze","recurDivMazeVertical","recurDivMazeHorizontal","primsAlgo","op","Navbar","collapseOnSelect","expand","bg","variant","Brand","onClick","window","location","reload","Toggle","aria-controls","Collapse","Nav","NavDropdown","style","opacity","title","Item","eventKey","Link","src","homeimg","alt","desinationimg","shortestpathimg","visitednodeimg","wallimg","Tutorial","handleTut","walldraw","instantpath","primsalgo","addedWalls","removedWalls","columns","open","frontier","j","getKey","n","randomKey","forEach","r","c","randFKey","neighbours","every","index","wr","wc","randNeighbour","Object","keys","obj","toString","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","MOUSE_PRESSED","START","END","FINISH","RUNNING","CURRENT_ALGO","PathfindingVisualizer","initializeGrid","document","getElementById","classList","remove","visualizeDijikstra","shortestpath","animateDijikstra","setTimeout","add","animateShortestPath","visualizeDfs","animateDfs","visualizeBfs","animateBfs","visualizeAstar","visitedNodesInorder","animateAstar","visualizeRecurssiveDivision","a","ROW","COL","animateRecurssiveDivision","visualizeRecurssiveDivisionVertical","visualizeRecurssiveDivisionHorizontal","visualizeRandomMaze","walls","visulizeprimsalgo","prims","makewall","animatePrims","createNode","instantPathStart","algorithm","instantPathDestination","load","addEventListener","preventDefault","getnewgridwithwallToggled","map","rowIdx","nodeIdx","isStart","isEnd","handleMouseDown","handleMouseUp","handleMouseEnter","App","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.15c895f3.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"static/media/destination.4a2d5368.png\";","module.exports = __webpack_public_path__ + \"static/media/yellow.1f2f0d99.png\";","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"static/media/drawwalls.1bdd83b4.gif\";","module.exports = __webpack_public_path__ + \"static/media/instant.c6426b26.gif\";","import React, { Component } from 'react'\nimport './Node.css'\n\nexport class Node extends Component {\n\n    render() {\n        const {\n                row,\n                column,\n                onMouseDown,\n                onMouseUp,\n                onMouseEnter,\n              }=this.props\n\n        return (\n            <>\n               <td \n               id= {`node-${row}-${column}`}\n               key={this.props.column} \n               className={`node`}\n               onMouseDown={(e) => onMouseDown(row, column,e)}\n               onMouseEnter={() => onMouseEnter(row, column)}\n               onMouseUp={() => onMouseUp()}\n               >\n\n               </td>\n            </>\n        )\n    }\n}\n\nexport default Node\n","//all nodes \nexport const getallNodes=(grid)=>{\n    let nodes=[]\n    for(let rows of grid){\n        for (let node of rows){\n            nodes.push(node)\n        }\n    }\n    return nodes\n}","import {getallNodes} from '../Helpers/getAllNodes'\n\nexport const dijkstra=(grid,start_node,finish_node)=>{\n     start_node.distance=0\n\n    //grab all the unviited nodes\n    let unvisitednodes=getallNodes(grid)\n    //visited nodes\n    let  visitedNodeInorder=[]\n\n\n    //don't think about the target node assume all the distances to be infinity\n    //we will visit all the nodes untill the target node is found\n    //firstly update the neighbour nodes distances \n    //select the current node which has lower cost then repeat\n\n    while(!!unvisitednodes.length){\n        //sorting by distance\n        sortBydistance(unvisitednodes)\n        //poping from left side\n        let currentNode=unvisitednodes.shift()\n\n        //if curr. Node is wall continue\n        if(currentNode.isWall) {\n            continue;\n        }\n\n        //when surrounded by walls\n        if(currentNode.distance===Infinity) return visitedNodeInorder;\n\n        //finish node found\n        if(currentNode===finish_node) return visitedNodeInorder;\n\n        //we dont want to visit a visited node again so make it true\n        currentNode.isVisited=true\n\n        //push visited node\n        visitedNodeInorder.push(currentNode)\n\n        //updateNeighbourDistances\n        updateCurrentNodeNeighbors(currentNode,grid)\n\n\n    }\n\n}\n\n//sort by distance\nconst sortBydistance=(unvisitednodes)=>{\n    unvisitednodes.sort((nodeA,nodeB)=>nodeA.distance-nodeB.distance)\n}\n\n//update the neighbour distances(cost)\nconst updateCurrentNodeNeighbors=(currentNode,grid)=>{\n    //get the neighbour nodes\n    const neighbors=getCurrentNodeNeighbors(currentNode,grid)\n\n    //iterate through each node \n    for(let node of neighbors){\n        node.distance=currentNode.distance+1\n        //keep track of prev node(parent node) to backtrack\n        node.previousNode=currentNode\n    }\n\n}\n\n//get all the neighbour\nconst getCurrentNodeNeighbors=(currentNode,grid)=>{\n    const neighbors = [];\n\n    const {column, row} = currentNode;\n\n    //top neighbour cell\n    if (row > 0) neighbors.push(grid[row - 1][column]);\n\n    //bottom neighbour cell\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][column]);\n\n\n    //left neighbour cell\n    if (column > 0) neighbors.push(grid[row][column - 1]);\n\n    //right neighbour cell\n    if (column < grid[0].length - 1) neighbors.push(grid[row][column + 1]);\n\n    //filter out he visited\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n\n}\n\n\n","\nexport const depthFirstSearch=(grid,startnode,finishnode)=>{\n    //assign the distance of startnode to zero\n    let visitedNodes=[]\n    //stack to keep track of unexplored nodes(we dont explore the node we go deep down)\n    let stack=[] \n    stack.push(startnode)\n\n    //repeat untill the stack is empty\n    //or target node is found\n    while(stack.length){\n        //current node \n        let currentNode=stack.pop()       \n        visitedNodes.push(currentNode)\n        //visited true,we wont visit it again\n        currentNode.isVisited=true\n        //target found\n        if(currentNode===finishnode) return visitedNodes;\n        //update the stack with neighbour value     \n        updateStack(grid,currentNode,stack)\n    }\n    \n    //target not found\n    return visitedNodes\n}\n\n\n\n//update stack\n const updateStack= (grid,currentNode,stack)=>{\n     //get the neighbour ORDER(left,bottom,right,top) since we are poping it out\n     //it will become(top,right,bottom,left)\n    let neighbors= getCurrentNodeNeighbors(currentNode,grid)\n\n    //push each neighbour to stack and update the distance ,prev node to back track\n    for(let node of neighbors){\n        stack.push(node)\n        node.previousNode=currentNode\n    }\n}   \n\n\n\n//neighbour nodes\nconst getCurrentNodeNeighbors=(currentNode,grid)=>{\n    const neighbors = [];\n\n    const {column, row} = currentNode;\n\n    //left cell\n    if (column > 0) neighbors.push(grid[row][column - 1]);\n\n    //bottom cell\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][column]);\n\n    //right cell\n    if (column < grid[0].length - 1) neighbors.push(grid[row][column + 1]);\n\n    //top cell\n    if (row > 0) neighbors.push(grid[row - 1][column]);\n\n    //filter out visited and wall nodes\n    return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\n\n}\n","export const breadthFirstSearch=(grid,start_node,finish_node)=>{\n    //assign distance to the start node \n    //we will keep track of all the branches in queue FIFO\n    let visitedNodes=[]\n    let queue=[]\n    queue.push(start_node) \n\n    //continue untill queue is empty or target node found  \n    while(queue.length){\n        let currentNode=queue.shift()\n        visitedNodes.push(currentNode)\n        currentNode.isVisited=true\n        //final node\n        if(currentNode===finish_node) {\n            return visitedNodes;\n        }\n\n        //update queue with neighbouring Node\n        updateQueue(grid,currentNode,queue)\n    }\nreturn visitedNodes\n\n}\n\n//update the queue \n const updateQueue= (grid,currentNode,queue)=>{\n     //get the neighbours\n    let neighbors= getCurrentNodeNeighbors(currentNode,grid)\n    //push each neighbour to the queue\n    for(let node of neighbors){\n        queue.push(node)\n        node.isVisited=true\n        node.previousNode=currentNode\n    }\n}   \n\n//get neighboour\nconst getCurrentNodeNeighbors=(currentNode,grid)=>{\n    const neighbors = [];\n\n    const {column, row} = currentNode;\n\n    if (row > 0) neighbors.push(grid[row - 1][column]);\n\n    if (column < grid[0].length - 1) neighbors.push(grid[row][column + 1]);\n\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][column]);\n\n    if (column > 0) neighbors.push(grid[row][column - 1]);\n\n   \n    //filter out visited and wall\n    return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\n\n}\n","export const astar=(grid,startNode,finishNode)=>{\n    //openlist where we push all the neighbours(about to explore)\n    let openlist=[]\n    //closed list where we push the visited nodes(already explored)\n    let closedlist=[]\n\n    //firstly we push startNode and to the open \n    startNode.distance=0\n    startNode.f=0\n    openlist.push(startNode)\n\n\n     while(openlist.length){\n         //we sort the openlist by F value\n        sortOpenlistByFvalue(openlist)\n\n        //current node is the node with least f value\n        //we explored it ,so we push it to closed list  \n        let currentNode=openlist.shift()\n        closedlist.push(currentNode)\n\n        //if we found the target node\n        if(currentNode===finishNode){\n            closedlist.push(currentNode)\n            return closedlist\n        }\n\n        //updatecurrent node distance(g),herustic(h) and F (h+g)\n        updateCurrentNodeNeighbors(currentNode,grid,finishNode,openlist,closedlist)\n        \n     }\n     //after all nodes explored\n     return closedlist\n}\n\n\n\n\n//sort the node based on f value \nconst sortOpenlistByFvalue=(openlist)=>{\n    openlist.sort((nodeA,nodeB)=> nodeA.f-nodeB.f)\n\n}\n\n\n//update neighbours of current node\nconst updateCurrentNodeNeighbors=(currentNode,grid,finishNode,openlist,closedlist)=>{\n   \n    let neighbors= getCurrentNodeNeighbors(currentNode,grid)\n\n//traversing through the neighbours\n    for(let node of neighbors){\n        \n        //if it is in openlist or it is a value we ignore\n        if(closedlist.includes(node) || node.isWall) continue;\n\n        //distance from start node to current Node\n        let tentativedistance=currentNode.distance+1\n\n        //if it is not in openlist it indicates that we have to update the node so we continue or\n        //if the current distance is less than (if it is in already in open list) previous distance ,update the node\n        if(!openlist.includes(node) || tentativedistance<node.distance){\n\n            node.distance=tentativedistance\n            \n            //update the h and f of the node\n            updateWithHeuristicAndF(node,finishNode)\n\n            //parent node to backtrack\n            node.previousNode=currentNode\n\n            //if it is not in open list push it to the open list\n            if(!openlist.includes(node)){\n             openlist.push(node)\n            } \n\n            //if it is in open list update with latest f and g value ,which will be lesser than prev\n            // else{      \n            //     upadateNodeInList(openlist,node)\n               \n            // }\n            \n        }\n       \n    }\n}\n\n\n\n\n//updating the node with greater f value in the open list with new updated f value(only for repeating neighbours)\n// const upadateNodeInList=(openlist,node)=>{\n//     for(let i=0;i<openlist.length;i++){\n//         if(node.row===openlist[i].row && node.column===openlist[i].column){\n//             openlist[i]=node\n//             sortOpenlistByFvalue(openlist)\n//             break\n//         }\n\n//     }\n// }\n\n\n\n//update the node with h ,f and g\nconst updateWithHeuristicAndF=(node,finishNode)=>{\n    //using Manhattan distance to guess H  it is |x1 - x2| + |y1 - y2| (distance b/w current node and finish node)\n    //you can also use Euclidean distance  sqrt((x1-x2)^2 +(y1-y2)^2)\n    //node.h=Math.sqrt(((node.row-finishNode.row)**2)+( (node.column-finishNode.column)**2))(try this)\n    node.h=Math.abs(node.row-finishNode.row)+Math.abs(node.column-finishNode.column)\n\n    //f=distance(g)+h\n    node.f=node.distance+node.h\n}\n\n\n\n//get all the neighbour\nconst getCurrentNodeNeighbors=(currentNode,grid)=>{\n    const neighbors = [];\n\n    const {column, row} = currentNode;\n\n    //top neighbour cell\n    if (row > 0) neighbors.push(grid[row - 1][column]);\n\n    //bottom neighbour cell\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][column]);\n    \n    //left neighbour cell\n    if (column > 0) neighbors.push(grid[row][column - 1]);\n\n    //right neighbour cell\n    if (column < grid[0].length - 1) neighbors.push(grid[row][column + 1]);\n\n    return neighbors\n\n\n}\n\n\n\n","//backtracking\nexport const getNodesInShortestPathOrder=(finishNode)=>{\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n","import {getallNodes} from '../Helpers/getAllNodes'\n\n//--size of the grid hardcoded (CHANGE THESE VALUES WHENEVER YOU CHANGE GRID SIZE)\nconst LAST_ROW=24\nconst LAST_COL=62\n\n export const recursiveDivisionMaze=(grid, rowStart, rowEnd, colStart, colEnd, orientation, surroundingWalls,visitednodes)=> {\n     //all the nodes\n    let nodes=getallNodes(grid)\n\n    //base case\n    if (rowEnd < rowStart || colEnd < colStart) {\n      return ;\n    }\n\n    //draw border walls \n    if (!surroundingWalls) {\n        for(let node of nodes){\n            //if it is a start node then continue\n            if(node.start) continue\n            //if it is end node then continue\n            if(node.end) continue\n            //first row , first column,last row,last column\n            if(node.row===0 || node.column===0 || node.row===LAST_ROW || node.column===LAST_COL){ //hard value of row and column \n                visitednodes.push(node)\n            }\n        }\n        //only during first call surrounding walls are generated\n        surroundingWalls=true\n\n    }\n\n    //if orientation is horizontal then we need to push the possible rows leaving one gap(i+2)\n    if (orientation === \"horizontal\") {\n      let possibleRows = [];\n      for (let i = rowStart; i <= rowEnd; i += 2) {\n        possibleRows.push(i);\n      }\n\n      ////if orientation is horizontal then we need to push the possible columns leaving one gap(i+2)\n      let possibleCols = [];\n      for (let i = colStart - 1; i <= colEnd + 1; i += 2) {\n        possibleCols.push(i);\n      }\n\n      //picking a random row  to devide the grid\n      //picking a random coloumn to give passage between them\n      let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n      let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n      let currentRow = possibleRows[randomRowIndex];\n      //creating door or [passage ]  by choosing the random column\n      let colRandom = possibleCols[randomColIndex];\n\n      //pushing all the current row nodes to visited node excluding the random column(door or passage) and start \n      for(let node of nodes){\n          if(node.row ===currentRow && node.column !== colRandom && node.column>=colStart-1 && node.column <=colEnd+1 && !node.start && !node.end){\n            visitednodes.push(node)\n          }\n      }\n\n      //UPPER ROOOM\n      //if horizontal upper room is more than the vertical room\n      //we will divide the room by given orientataion(horizontal)\n      if (currentRow - 2 - rowStart > colEnd - colStart) {\n        recursiveDivisionMaze(grid, rowStart, currentRow - 2, colStart, colEnd, orientation, surroundingWalls,visitednodes);\n      }\n      //else if vertical room is more than horizontal room we divide it the room (space) vertically\n       else {\n        recursiveDivisionMaze(grid, rowStart, currentRow - 2, colStart, colEnd, \"vertical\", surroundingWalls,visitednodes);\n      }\n\n\n      //LOWER ROOM\n      //if horizontal upper room is more than the vertical room\n      //we will divide the room by given orientataion(horizontal)\n      if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n        recursiveDivisionMaze(grid, currentRow + 2, rowEnd, colStart, colEnd, orientation, surroundingWalls,visitednodes);\n      }\n      //else if vertical room is more than horizontal room we divide it the room (space) vertically \n      else {\n        recursiveDivisionMaze(grid, currentRow + 2, rowEnd, colStart, colEnd, \"vertical\", surroundingWalls,visitednodes);\n      }\n    }\n\n\n//================================FOR VERTICAL ORIENTATION============\n     else {\n       //if orientation is vertical then we need to push the possible columns leaving one gap(i+2)\n      let possibleCols = [];\n      for (let i = colStart; i <= colEnd; i += 2) {\n        possibleCols.push(i);\n      }\n\n      ////if orientation is vertical then we need to push the possible columns leaving one gap(i+2)\n      let possibleRows = [];\n      for (let i = rowStart - 1; i <= rowEnd + 1; i += 2) {\n        possibleRows.push(i);\n      }\n\n      //picking a random column  to devide the grid\n      //picking a random row to give passage between them\n      let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n      let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n      //current column to divide\n      let currentCol = possibleCols[randomColIndex];\n\n      //creating door or [passage]  by choosing the random row\n      let rowRandom = possibleRows[randomRowIndex];\n\n      //pushing all the current column nodes to visited node excluding the random row(door or passage) and start (all columns must be in between divided space)\n      for(let node of nodes){\n        if(node.column ===currentCol && node.row !== rowRandom && node.row>=rowStart-1 && node.row <=rowEnd+1 && !node.start && !node.end){\n          node.isWall=true\n          visitednodes.push(node)\n        }\n    }\n\n      //LEFT ROOM\n      //if horizontal left room is more than the vertical room\n      //we will divide the room by horizontal\n      if (rowEnd - rowStart > currentCol - 2 - colStart) {\n        recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, currentCol - 2, \"horizontal\", surroundingWalls,visitednodes);\n      }   \n      \n      //if the vertical room is more than horizontal \n      //we will divide the room by given orientation\n      else {\n        recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, currentCol - 2, orientation, surroundingWalls,visitednodes);\n      }\n\n      //RIGHT ROOM\n      //if vertical RIGHT room is more than the horizontal room\n      //we will divide the room by horizontal      \n      if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n        recursiveDivisionMaze(grid, rowStart, rowEnd, currentCol + 2, colEnd, \"horizontal\", surroundingWalls,visitednodes);\n      }\n      \n      //if horizontal RIGHT room is more than the vertical room\n      //we will divide the room by given orientation\n      else {\n        recursiveDivisionMaze(grid, rowStart, rowEnd, currentCol + 2, colEnd, orientation, surroundingWalls,visitednodes);\n      }\n    }\n    \n    return visitednodes\n\n  };\n\n","import {getallNodes} from '../Helpers/getAllNodes'\n\n\n//--size of the grid hardcoded (CHANGE THESE VALUES WHENEVER YOU CHANGE GRID SIZE)\nconst LAST_ROW=24\nconst LAST_COL=62\n\n\n export const recurssiveVerticalSkew=(grid, rowStart, rowEnd, colStart, colEnd, orientation, surroundingWalls,visitednodes)=> {\n     //all the nodes\n    let nodes=getallNodes(grid)\n\n    //base case\n    if (rowEnd < rowStart || colEnd < colStart) {\n      return ;\n    }\n\n    //draw border walls \n    if (!surroundingWalls) {\n        for(let node of nodes){\n            //if it is a start node then continue\n            if(node.start) continue\n            //if it is end node then continue\n            if(node.end) continue\n            //first row , first column,last row,last column\n            if(node.row===0 || node.column===0 || node.row===LAST_ROW || node.column===LAST_COL){ //hard value of row and column \n                visitednodes.push(node)\n            }\n        }\n        //only during first call surrounding walls are generated\n        surroundingWalls=true\n\n    }\n\n    //if orientation is horizontal then we need to push the possible rows leaving one gap(i+2)\n    if (orientation === \"horizontal\") {\n      let possibleRows = [];\n      for (let i = rowStart; i <= rowEnd; i += 2) {\n        possibleRows.push(i);\n      }\n\n      ////if orientation is horizontal then we need to push the possible columns leaving one gap(i+2)\n      let possibleCols = [];\n      for (let i = colStart - 1; i <= colEnd + 1; i += 2) {\n        possibleCols.push(i);\n      }\n\n      //picking a random row  to devide the grid\n      //picking a random coloumn to give passage between them\n      let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n      let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n      let currentRow = possibleRows[randomRowIndex];\n      //creating door or [passage ]  by choosing the random column\n      let colRandom = possibleCols[randomColIndex];\n\n      //pushing all the current row nodes to visited node excluding the random column(door or passage) and start \n      for(let node of nodes){\n          if(node.row ===currentRow && node.column !== colRandom && node.column>=colStart-1 && node.column <=colEnd+1 && !node.start && !node.end){\n\n            visitednodes.push(node)\n          }\n      }\n\n      //UPPER ROOOM\n      //if horizontal upper room is more than the vertical room\n      //we will divide the room by given orientataion(horizontal)\n      if (currentRow - 2 - rowStart > colEnd - colStart) {\n        recurssiveVerticalSkew(grid, rowStart, currentRow - 2, colStart, colEnd, orientation, surroundingWalls,visitednodes);\n      }\n      //else if vertical room is more than horizontal room we divide it the room (space) vertically\n       else {\n        recurssiveVerticalSkew(grid, rowStart, currentRow - 2, colStart, colEnd, \"vertical\", surroundingWalls,visitednodes);\n      }\n\n\n      //LOWER ROOM\n      //if horizontal lower room is more than the vertical room\n      //we will divide the room by vertical\n      if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n        recurssiveVerticalSkew(grid, currentRow + 2, rowEnd, colStart, colEnd, \"vertical\", surroundingWalls,visitednodes);\n      }\n      //else if vertical room is more than horizontal room we divide it the room (space) vertically \n      else {\n        recurssiveVerticalSkew(grid, currentRow + 2, rowEnd, colStart, colEnd, \"vertical\", surroundingWalls,visitednodes);\n      }\n    }\n\n\n//================================FOR VERTICAL ORIENTATION============\n     else {\n       //if orientation is vertical then we need to push the possible columns leaving one gap(i+2)\n      let possibleCols = [];\n      for (let i = colStart; i <= colEnd; i += 2) {\n        possibleCols.push(i);\n      }\n\n\n      ////if orientation is vertical then we need to push the possible columns leaving one gap(i+2)\n      let possibleRows = [];\n      for (let i = rowStart - 1; i <= rowEnd + 1; i += 2) {\n        possibleRows.push(i);\n      }\n\n      //picking a random column  to devide the grid\n      //picking a random row to give passage between them\n      let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n      let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n      //current column to divide\n      let currentCol = possibleCols[randomColIndex];\n\n      //creating door or [passage]  by choosing the random row\n      let rowRandom = possibleRows[randomRowIndex];\n\n      //pushing all the current column nodes to visited node excluding the random row(door or passage) and start (all columns must be in between divided space)\n      for(let node of nodes){\n        if(node.column ===currentCol && node.row !== rowRandom && node.row>=rowStart-1 && node.row <=rowEnd+1 && !node.start && !node.end){\n          node.isWall=true\n          visitednodes.push(node)\n        }\n    }\n\n      //LEFT ROOM\n      //if horizontal left room is more than the vertical room\n      //we will divide the room by vertical(vertical-skew)\n      if (rowEnd - rowStart > currentCol - 2 - colStart) {\n        recurssiveVerticalSkew(grid, rowStart, rowEnd, colStart, currentCol - 2, \"vertical\", surroundingWalls,visitednodes);\n      }   \n      \n      //if the vertical room is more than horizontal \n      //we will divide the room by given orientation(vertical)\n      else {\n        recurssiveVerticalSkew(grid, rowStart, rowEnd, colStart, currentCol - 2, orientation, surroundingWalls,visitednodes);\n      }\n\n      //RIGHT ROOM\n      //if vertical right room is more than the horizontal room\n      //we will divide the room by horizontal      \n      if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n        recurssiveVerticalSkew(grid, rowStart, rowEnd, currentCol + 2, colEnd, \"horizontal\", surroundingWalls,visitednodes);\n      }\n      \n      //if horizontal right room is more than the vertical room\n      //we will divide the room by given orientation\n      else {\n        recurssiveVerticalSkew(grid, rowStart, rowEnd, currentCol + 2, colEnd, orientation, surroundingWalls,visitednodes);\n      }\n    }\n    \n    return visitednodes\n\n  };","import {getallNodes} from '../Helpers/getAllNodes'\n\n//--size of the grid hardcoded (CHANGE THESE VALUES WHENEVER YOU CHANGE GRID SIZE)\nconst LAST_ROW=24\nconst LAST_COL=62\n\n export const recurssiveHorizontalSkew=(grid, rowStart, rowEnd, colStart, colEnd, orientation, surroundingWalls,visitednodes)=> {\n     //all the nodes\n    let nodes=getallNodes(grid)\n\n    //base case\n    if (rowEnd < rowStart || colEnd < colStart) {\n      return ;\n    }\n\n    //draw border walls \n    if (!surroundingWalls) {\n        for(let node of nodes){\n            //if it is a start node then continue\n            if(node.start) continue\n            //if it is end node then continue\n            if(node.end) continue\n            //first row , first column,last row,last column\n            if(node.row===0 || node.column===0 || node.row===LAST_ROW || node.column===LAST_COL){ //hard value of row and column \n                visitednodes.push(node)\n            }\n        }\n        //only during first call surrounding walls are generated\n        surroundingWalls=true\n\n    }\n\n    //if orientation is horizontal then we need to push the possible rows leaving one gap(i+2)\n    if (orientation === \"horizontal\") {\n      let possibleRows = [];\n      for (let i = rowStart; i <= rowEnd; i += 2) {\n        possibleRows.push(i);\n      }\n\n      ////if orientation is horizontal then we need to push the possible columns leaving one gap(i+2)\n      let possibleCols = [];\n      for (let i = colStart - 1; i <= colEnd + 1; i += 2) {\n        possibleCols.push(i);\n      }\n\n      //picking a random row  to devide the grid\n      //picking a random coloumn to give passage between them\n      let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n      let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n      let currentRow = possibleRows[randomRowIndex];\n      //creating door or [passage ]  by choosing the random column\n      let colRandom = possibleCols[randomColIndex];\n\n      //pushing all the current row nodes to visited node excluding the random column(door or passage) and start \n      for(let node of nodes){\n          if(node.row ===currentRow && node.column !== colRandom && node.column>=colStart-1 && node.column <=colEnd+1 && !node.start && !node.end){\n\n            visitednodes.push(node)\n          }\n      }\n\n      //UPPER ROOOM\n      //if horizontal upper room is more than the vertical room\n      //we will divide the room by given orientataion(horizontal)\n      if (currentRow - 2 - rowStart > colEnd - colStart) {\n        recurssiveHorizontalSkew(grid, rowStart, currentRow - 2, colStart, colEnd, orientation, surroundingWalls,visitednodes);\n      }\n      //else if vertical room is more than horizontal room we divide it the room (space) Horizontally(so it is called as horizontal skew)\n       else {\n        recurssiveHorizontalSkew(grid, rowStart, currentRow - 2, colStart, colEnd, \"horizontal\", surroundingWalls,visitednodes);\n      }\n\n\n      //LOWER ROOM\n      //if horizontal lower room is more than the vertical room\n      //we will divide the room by given orientataion(horizontal)\n      if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n        recurssiveHorizontalSkew(grid, currentRow + 2, rowEnd, colStart, colEnd, orientation, surroundingWalls,visitednodes);\n      }\n\n      //else if vertical room is more than horizontal room we divide it the room (space) vertically (for just complexity)\n      else {\n        recurssiveHorizontalSkew(grid, currentRow + 2, rowEnd, colStart, colEnd, \"vertical\", surroundingWalls,visitednodes);\n      }\n    }\n\n\n//================================FOR VERTICAL ORIENTATION============\n     else {\n       //if orientation is vertical then we need to push the possible columns leaving one gap(i+2)\n      let possibleCols = [];\n      for (let i = colStart; i <= colEnd; i += 2) {\n        possibleCols.push(i);\n      }\n\n\n      ////if orientation is vertical then we need to push the possible columns leaving one gap(i+2)\n      let possibleRows = [];\n      for (let i = rowStart - 1; i <= rowEnd + 1; i += 2) {\n        possibleRows.push(i);\n      }\n\n      //picking a random column  to devide the grid\n      //picking a random row to give passage between them\n      let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n      let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n      //current column to divide\n      let currentCol = possibleCols[randomColIndex];\n\n      //creating door or [passage]  by choosing the random row\n      let rowRandom = possibleRows[randomRowIndex];\n\n      //pushing all the current column nodes to visited node excluding the random row(door or passage) and start (all columns must be in between divided space)\n      for(let node of nodes){\n        if(node.column ===currentCol && node.row !== rowRandom && node.row>=rowStart-1 && node.row <=rowEnd+1 && !node.start && !node.end){\n          node.isWall=true\n          visitednodes.push(node)\n        }\n    }\n\n      //LEFT ROOM\n      //if horizontal left room is more than the vertical room\n      //we will divide the room by horizontal\n      if (rowEnd - rowStart > currentCol - 2 - colStart) {\n        recurssiveHorizontalSkew(grid, rowStart, rowEnd, colStart, currentCol - 2, \"horizontal\", surroundingWalls,visitednodes);\n      }   \n      \n      //if the vertical room is more than horizontal \n      //we will divide the room by horizontal(horizontal skew)\n      else {\n        recurssiveHorizontalSkew(grid, rowStart, rowEnd, colStart, currentCol - 2, \"horizontal\", surroundingWalls,visitednodes);\n      }\n\n      //RIGHT ROOM\n      //if vertical right room is more than the horizontal room\n      //we will divide the room by horizontal      \n      if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n        recurssiveHorizontalSkew(grid, rowStart, rowEnd, currentCol + 2, colEnd, \"horizontal\", surroundingWalls,visitednodes);\n      }\n      \n      //if horizontal right room is more than the vertical room\n      //we will divide the room by given orientation (vertical)\n      else {\n        recurssiveHorizontalSkew(grid, rowStart, rowEnd, currentCol + 2, colEnd, orientation, surroundingWalls,visitednodes);\n      }\n    }\n    \n    return visitednodes\n\n  };\n\n","import {getallNodes} from '../Helpers/getAllNodes';\nexport const randomMaze=(grid)=>{\n    let nodes=getallNodes(grid)\n    let visitednode=[]\n    let counter=0\n\n    // nodes.length/3 indicates 70% walls\n    while(counter!==Math.floor(nodes.length/3)){\n        //pushing some random index of nodes\n        //return arandom index\n        let randomIndex = Math.floor(Math.random() * nodes.length);\n\n        if(nodes[randomIndex].start) continue;\n        if(nodes[randomIndex].end) continue;\n\n        visitednode.push(nodes[randomIndex])\n        counter+=1\n    }\nreturn visitednode\n\n}","import './NavBar.css'\nimport React, { Component } from 'react'\nimport { Navbar,Nav,NavDropdown } from 'react-bootstrap';\nimport homeimg from '../Node/images/initial.png'\nimport desinationimg from '../Node/images/destination.png'\nimport shortestpathimg from '../Node/images/yellow.png'\nimport visitednodeimg from '../Node/images/purple.png'\nimport wallimg from '../Node/images/wall.png'\n\nexport class NavBar extends Component {\n    constructor(props) {\n        super(props)\n    \n        this.state = {\n             is_running:false\n        }\n    }\n    \n\n    componentWillReceiveProps(props) {\n        if(this.state.is_running===false) return\n        this.setState({is_running: props.is_running })\n      }\n    \n    render() {\n        const {clearGrid,clearPath,astar,dijkstra,bfs,dfs,recurDivMaze,randomMaze,recurDivMazeVertical,recurDivMazeHorizontal,primsAlgo}=this.props\n        const  {is_running}=this.state\n        let op=is_running?\"0.2\":\"1\"\n        return (\n            <>\n                <Navbar collapseOnSelect expand=\"lg\" bg=\"dark\" variant=\"dark\" >\n                    <Navbar.Brand id=\"header\" onClick={()=>{window.location.reload()}}>Pathfinding Visualizer</Navbar.Brand>\n                    <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n                    <Navbar.Collapse  id=\"responsive-navbar-nav\" >\n                        <Nav className=\"mr-auto\">\n                            <NavDropdown style={{opacity:op}} title=\"Pick an Algorithm to Visualize\" id=\"collasible-nav-dropdown\">\n                                <NavDropdown.Item  onClick={!is_running ? ()=>{this.setState({is_running:true})\n                                    return astar()}:null} variant=\"dark\">A* Search</NavDropdown.Item>\n\n                                <NavDropdown.Item   onClick={!is_running ? ()=>{this.setState({is_running:true})\n                                    return dijkstra()}:null} >Dijkstra's Algorithm</NavDropdown.Item>\n\n                                <NavDropdown.Item   onClick={!is_running ? ()=>{this.setState({is_running:true})\n                                    return bfs()}:null}>Breadth-first Search</NavDropdown.Item>\n\n                                <NavDropdown.Item eventKey={3}  onClick={!is_running ? ()=>{this.setState({is_running:true})\n                                    return dfs()}:null} >Depth-first Search</NavDropdown.Item>\n                            </NavDropdown>\n\n                            <NavDropdown style={{opacity:op}} title=\"Generate Mazes\" id=\"collasible-nav-dropdown\">\n\n                                <NavDropdown.Item   onClick={!is_running ? ()=>{this.setState({is_running:true})\n                                    return primsAlgo()}:null}>Prim's Algorithm</NavDropdown.Item>\n\n                                <NavDropdown.Item   onClick={!is_running ? ()=>{this.setState({is_running:true})\n                                    return recurDivMaze()}:null}>Recurssive Division</NavDropdown.Item>\n\n                                <NavDropdown.Item   onClick={!is_running ? ()=>{this.setState({is_running:true})\n                                    return randomMaze()}:null} >Random Maze</NavDropdown.Item>\n                                    \n                                <NavDropdown.Item   onClick={!is_running ? ()=>{this.setState({is_running:true})\n                                    return recurDivMazeVertical()}:null}>Recurssive Division (Vertical-skew)</NavDropdown.Item>\n\n                                <NavDropdown.Item   onClick={!is_running ? ()=>{this.setState({is_running:true})\n                                    return recurDivMazeHorizontal()}:null}>Recurssive Division (Horizontal-skew)</NavDropdown.Item>\n                                \n                            </NavDropdown>\n                        </Nav>\n                        <Nav>\n                        <Nav.Link style={{opacity:op}} onClick={!is_running ? ()=>clearPath():null}>Clear Path</Nav.Link>\n\n                        <Nav.Link style={{opacity:op}} eventKey={2} onClick={!is_running ? ()=>clearGrid():null}>\n                            Clear Board\n                        </Nav.Link>\n                        </Nav>\n                    </Navbar.Collapse>\n                </Navbar>\n\n                <div className=\"notations\">\n                    <div className=\"notation\">\n                        <img src={homeimg} alt=\"source\"></img>\n                        <span>Starting Point</span>\n                    </div>\n                    <div className=\"notation\">\n                    <img src={desinationimg} alt=\"destination\"></img><span>Destination</span>\n                    </div>\n                    <div className=\"notation\">\n                    <img src={shortestpathimg} alt=\"shortpath\"></img><span>Shortest Path</span>\n                    </div>\n                    <div className=\"notation\">\n                    <img src={visitednodeimg} alt=\"visited\"></img><span> Visited Nodes</span>\n                    </div>\n                    <div className=\"notation\">\n                    <img src={wallimg} alt=\"wall\"></img><span> Wall</span>\n                    </div>\n                </div>\n\n\n            </>\n        )\n    }\n}\n\nexport default NavBar\n","import React, { Component } from 'react'\nimport './Tutorial.css';\nimport walldraw from '../Node/images/drawwalls.gif'\nimport instantpath from '../Node/images/instant.gif'\n\nexport class Tutorial extends Component {\n    render() {\n        const {handleTut}=this.props\n        return (\n            <>\n                <div className=\"tut\">\n                    <div className=\"tut__heading\"> \n                        <h2> QUICK GUIDE</h2>\n                        <button onClick={()=>{handleTut()}}>Skip</button>\n                    </div>\n                    <div className=\"tut__content\">\n                        <div className=\"tutcontent\">\n                            <h4>A* Search Algorithm</h4>\n                            <p>A* Search algorithm is one of the best and popular technique used in path-finding and graph traversals.\n                            A* Search algorithms, unlike other traversal techniques, it has “brains”. What it means is that it is really a smart algorithm which separates it from the other conventional algorithms.\n                            </p>\n                        </div>\n                        <div className=\"tutcontent\">\n                            <h4>Dijkstra's Shortest Path Algorithm</h4>\n                            <p>One algorithm for finding the shortest path from a starting node to a target node in a weighted graph is Dijkstra’s algorithm. The algorithm creates a tree of shortest paths from the starting vertex, the source, to all other points in the graph.\n                            </p>\n                        </div>\n                        <div className=\"tutcontent\">\n                            <h4>Breadth First Search</h4>\n                            <p>BFS is a traversing algorithm where you should start traversing from a selected node (source or starting node) and traverse the graph layerwise thus exploring the neighbour nodes (nodes which are directly connected to source node). You must then move towards the next-level neighbour nodes.\n                            </p>\n                        </div>\n                        <div className=\"tutcontent\">\n                            <h4>Depth First Search </h4>\n                            <p>Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.\n                            </p>\n                        </div>\n\n                        <div className=\"images\">\n                            <h4>How to draw walls ?</h4>\n                            <img src={walldraw} alt=\"walldrawgif\"></img>\n                            <h4>How to get  shortest path instantly ?</h4>\n                            <img src={instantpath} alt=\"instantpath\"></img>\n                        </div>\n                        <div className=\"tutcontent\">\n                            <h4>How to Visualize ? </h4>\n                            <p>Just pick an algorithm from drop down to Visualize.</p>\n                            <p>To Visualize maze generation pick any of the maze generation algorithm from dropdown</p>\n                        </div>\n                    </div>\n                  \n\n                        <button onClick={()=>{handleTut()}}>Finish</button>   \n                    \n                </div>\n            </>\n        )\n    }\n}\n\nexport default Tutorial\n","export const primsalgo=(grid,startnode,finishnode)=>{\r\n  let addedWalls = [];\r\n  let removedWalls = [];\r\n  \r\n  let rows= grid.length\r\n  let columns= grid[0].length\r\n\r\n  let open = {};\r\n  let frontier = {};\r\n\r\n  for (let i = 0; i < rows; i++) {\r\n    for (let j = 0; j < columns; j++) {\r\n      if (i % 2 === 0 || j % 2 === 0) {\r\n\r\n      } \r\n      else open[getKey(i, j)] = grid[i][j];\r\n\r\n      if(grid[i][j].start || grid[i][j].end) continue\r\n      //for each node add walls\r\n      grid[i][j].isWall = true;\r\n      addedWalls.push(grid[i][j]);\r\n    }\r\n  }\r\n\r\n  //boundary\r\n  const f = [\r\n    [2, 0],\r\n    [-2, 0],\r\n    [0, 2],\r\n    [0, -2]\r\n  ];\r\n\r\n  //neighbours\r\n  const n = [\r\n    [1, 0],\r\n    [-1, 0],\r\n    [0, 1],\r\n    [0, -1]\r\n  ];\r\n\r\n  //pick a random value from open and consider it as start node \r\n  const start = open[randomKey(open)];\r\n  //remove the wall\r\n  grid[start.row][start.column].isWall = false;\r\n  //push to removed wall\r\n  removedWalls.push(grid[start.row][start.column]);\r\n\r\n  f.forEach(i => {\r\n    const r = start.row + i[0]; //startrow + 2, statrow-2, startrow+0, startrow+0\r\n    const c = start.column + i[1]; //startcol + 0, startcol + 0 ,startcol +2 ,startcol-2\r\n\r\n    if (\r\n      grid[r] && //if that row exsist\r\n      grid[r][c] && //if that row and col exsist\r\n      grid[r][c].isWall && //if it is a wall\r\n      r !== 0 && //it is not the 0 th row\r\n      c !== 0 && //it is not the 0 th col\r\n      r !== rows - 1 && //it is not the end row \r\n      c !== columns - 1 //it is not the end column\r\n    )\r\n    //then push it to frontier\r\n      frontier[getKey(r, c)] = grid[r][c];\r\n  });\r\n  // console.log(frontier)\r\n\r\n  while (Object.keys(frontier).length) //continue till border(frontier) not empty\r\n   {\r\n    const randFKey = randomKey(frontier); //get a random key\r\n\r\n    const { row, column } = frontier[randFKey]; //get that element row and col\r\n\r\n    let neighbours = {}\r\n\r\n    f.every((i, index) => {\r\n      //boundary\r\n      const r = row + i[0]; //row+2,row-2,row+0,row-0\r\n      const c = column + i[1];//col+0,col-0,col+2,col-0\r\n      //get neighbours\r\n      const wr = row + n[index][0];\r\n      const wc = column + n[index][1];\r\n      //if neighbours exsist and it is wall then add that to neighbours\r\n      if (grid[r] && grid[r][c] && !grid[r][c].isWall) {\r\n        neighbours[getKey(wr, wc)] = grid[wr][wc];\r\n      }\r\n      //if boundary is not preset then return \r\n      return true;\r\n    });\r\n    \r\n    //get a random neighbour\r\n    const randNeighbour = neighbours[randomKey(neighbours)];\r\n    //remove the wall\r\n    grid[randNeighbour.row][randNeighbour.column].isWall = false;\r\n    grid[frontier[randFKey].row][frontier[randFKey].column].isWall = false; \r\n    removedWalls.push(grid[randNeighbour.row][randNeighbour.column]); //remove wall of rnadom neighbour\r\n    removedWalls.push(grid[frontier[randFKey].row][frontier[randFKey].column]);//remove the walls for that key in fromtier\r\n\r\n\r\n    //for that particticular rnadkey find the boundary and push it to frontier\r\n    f.forEach(i => {\r\n      const r = frontier[randFKey].row + i[0];\r\n      const c = frontier[randFKey].column + i[1];\r\n      if (\r\n        grid[r] && //if that row exsist\r\n        grid[r][c] &&  //if that row and col exsist\r\n        grid[r][c].isWall && //if it is a wall\r\n        r !== 0 && //it is not the 0 th row\r\n        c !== 0 && //it is not the 0 th col\r\n        r !== rows - 1 && //it is not the end row\r\n        c !== columns - 1 //it is not the end column\r\n      )\r\n        frontier[getKey(r, c)] = grid[r][c]; //push to frontier\r\n    });\r\n    delete frontier[randFKey]; //delete the rnadom key value from frontier\r\n  }\r\n  return { addedWalls, removedWalls};\r\n};\r\n\r\n\r\n\r\n//generate a random key\r\nconst randomKey = obj => {\r\n  var keys = Object.keys(obj);\r\n  return keys[(keys.length * Math.random()) << 0];\r\n};\r\n\r\n//convert row and col to key \"row-col\"\r\nconst getKey = (i, j) => {\r\n  return i.toString() + \"-\" + j.toString();\r\n};\r\n\r\n\r\n","import React, { Component } from 'react'\nimport Node from './Node/Node'\nimport './PathfindingVisualizer.css';\nimport {dijkstra}  from '../../algorithms/dijkstra';\nimport {depthFirstSearch}  from '../../algorithms/depthFirstSearch'\nimport {breadthFirstSearch}  from '../../algorithms/breadthFirstSearch'\nimport {astar}  from '../../algorithms/astar'\nimport {getNodesInShortestPathOrder} from '../../Helpers/backTrack'\nimport {getallNodes} from '../../Helpers/getAllNodes'\nimport {recursiveDivisionMaze} from '../../mazegeneraionAlgo/recurssiveDivision'\nimport {recurssiveVerticalSkew} from '../../mazegeneraionAlgo/recurDivVerticalSkew'\nimport {recurssiveHorizontalSkew} from '../../mazegeneraionAlgo/recurDivHorizontal'\nimport {randomMaze} from '../../mazegeneraionAlgo/randomMaze'\nimport NavBar from './NavBar/NavBar'\nimport {Tutorial} from './TutorialPopup/Tutorial'\nimport {primsalgo} from '../../mazegeneraionAlgo/PrimsAlgo';\nimport { wait } from '@testing-library/react';\n\n\n\n//------------------------------------------------------------global variables-------------------------------------------------------\n//Initialize grid size(even numbers)(dont forget to change maze algorithm PS:in case you change)\nconst ROW=24\nconst COL=62\n//change onload start and end positions here\nlet START_NODE_ROW = 10;\nlet START_NODE_COL = 12;\nlet FINISH_NODE_ROW = 10;\nlet  FINISH_NODE_COL = 48;\n\n//change animation speed here\nconst ANIMATION_SPEED=15;\nconst FINAL_PATH_ANIM_SPEED=20;\n\n//variables to handle some of the mouse events\nlet MOUSE_PRESSED=false\nlet START=false\nlet END=false\n\n\n//animation running finshed or not\n//current algorithm to instantanty find the path\nlet FINISH=false\nlet RUNNING=false\nlet CURRENT_ALGO=\"\"\n\n\nexport class PathfindingVisualizer extends Component {\n    constructor(props) {\n        super(props)\n    \n        this.state = {\n             grid:[],\n             is_running:false,\n             load:true\n\n        }\n    }\n\n\n\n    //-------------------------------------------------------------INITIALIZE GRID-----------------------------------------------------\n    async componentWillMount(){\n        const grid =initializeGrid()\n        await this.setState({grid})\n\n        //start node and end node\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).classList.add('node-start')\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).classList.add('node-end')\n        //bug fix outside the grid mouseup was not triggering\n        window.addEventListener('mouseup',()=>{\n            MOUSE_PRESSED=false\n            START=false\n        })\n\n    }\n\n\n    //-------------------------------------------------------------CLEAR GRID----------------------------------------------------------------\n    clearGrid=()=>{\n        const grid =initializeGrid()\n        this.setState({grid})\n        FINISH=false\n        CURRENT_ALGO=\"\"\n        let nodes=getallNodes(grid)\n            for(let i=0;i<nodes.length;i++){\n            document.getElementById(`node-${nodes[i].row}-${nodes[i].column}`).classList.remove('node-visited')\n            document.getElementById(`node-${nodes[i].row}-${nodes[i].column}`).classList.remove('shortest-path')\n            document.getElementById(`node-${nodes[i].row}-${nodes[i].column}`).classList.remove('node-wall')\n            }\n    }\n\n//--------------------------------------------------------------DIJKSTRA-----------------------------------------------------------------\n\n    //visualize\n        visualizeDijikstra=()=>{\n        const {grid}=this.state\n        this.clearPath()\n        RUNNING=true\n        CURRENT_ALGO=\"DIJKSTRA\"\n        //get start and finish node ,call dijkstra\n        //and backtracking helper to get shortest path\n        let start_node=grid[START_NODE_ROW][START_NODE_COL]\n        let finish_node=grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n        let visitedNodeInorder=dijkstra(grid,start_node,finish_node)\n        let shortestpath=getNodesInShortestPathOrder(finish_node)\n        this.animateDijikstra(visitedNodeInorder,shortestpath) \n\n    }\n\n\n\n    //animate\n    animateDijikstra=(visitedNodeInorder,shortestpath)=>{\n        for(let i=0;i<visitedNodeInorder.length;i++){\n            setTimeout(() => {\n                document.getElementById(`node-${visitedNodeInorder[i].row}-${visitedNodeInorder[i].column}`).classList.add('node-visited')\n                if(i===visitedNodeInorder.length-1){\n                    this.animateShortestPath(shortestpath)        \n            }\n\n\n            }, i*ANIMATION_SPEED);\n        }\n    }\n\n\n\n //------------------------------------------------------DEPTH FIRST SEARCH--------------------------------------------------\n\n    //visualize\n    visualizeDfs=()=>{\n        const {grid}=this.state\n        this.clearPath()\n        RUNNING=true\n        CURRENT_ALGO=\"DFS\"\n        let start_node=grid[START_NODE_ROW][START_NODE_COL]\n        let finish_node=grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n        let visitedNodeInorder=depthFirstSearch(grid,start_node,finish_node)\n        let shortestpath=getNodesInShortestPathOrder(finish_node)\n        this.animateDfs(visitedNodeInorder,shortestpath)\n    }\n\n\n    //animate DFS\n    animateDfs=(visitedNodeInorder,shortestpath)=>{\n        \n        for(let i=0;i<visitedNodeInorder.length;i++){\n\n            setTimeout(() => {\n                document.getElementById(`node-${visitedNodeInorder[i].row}-${visitedNodeInorder[i].column}`).classList.add('node-visited')\n                if(i===visitedNodeInorder.length-1){\n                    this.animateShortestPath(shortestpath)\n            }\n\n            }, i*ANIMATION_SPEED);\n        }\n    }\n\n\n//-----------------------------------------------------BREADTH FIRST SEARCH--------------------------------------------------------------\n    visualizeBfs=()=>{\n        const {grid}=this.state\n        this.clearPath()\n        RUNNING=true\n        CURRENT_ALGO=\"BFS\"\n        let start_node=grid[START_NODE_ROW][START_NODE_COL]\n        let finish_node=grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n        \n        let visitedNodeInorder=breadthFirstSearch(grid,start_node,finish_node)\n        let shortestpath=getNodesInShortestPathOrder(finish_node)\n        this.animateBfs(visitedNodeInorder,shortestpath)\n\n    }\n\n\n    //animate BFS\n    animateBfs=(visitedNodeInorder,shortestpath)=>{\n        \n        for(let i=0;i<visitedNodeInorder.length;i++){\n\n            setTimeout(() => {\n                document.getElementById(`node-${visitedNodeInorder[i].row}-${visitedNodeInorder[i].column}`).classList.add('node-visited')\n                if(i===visitedNodeInorder.length-1){\n                    this.animateShortestPath(shortestpath)\n            }\n\n            }, i*ANIMATION_SPEED);\n        }\n    }\n\n\n    //--------------------------------------------------------------------ASTAR--------------------------------------------------------\n    visualizeAstar=()=>{\n        const {grid}=this.state\n        this.clearPath()\n        RUNNING=true\n        CURRENT_ALGO=\"ASTAR\"\n        let start_node=grid[START_NODE_ROW][START_NODE_COL]\n        let finish_node=grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n        let visitedNodesInorder=astar(grid,start_node,finish_node)\n        let shortestpath=getNodesInShortestPathOrder(finish_node)\n        this.animateAstar(visitedNodesInorder,shortestpath)\n    }\n\n    //animate Astar\n    animateAstar=(visitedNodeInorder,shortestpath)=>{\n        \n        for(let i=0;i<visitedNodeInorder.length;i++){\n\n            setTimeout(() => {\n                document.getElementById(`node-${visitedNodeInorder[i].row}-${visitedNodeInorder[i].column}`).classList.add('node-visited')\n                if(i===visitedNodeInorder.length-1){\n                    //animate shortest path\n                    this.animateShortestPath(shortestpath)\n            }\n\n            }, i*ANIMATION_SPEED);\n        }\n    }\n\n //==================================================animate ShortestPath (BACKTRACKING)=========================================\n    animateShortestPath=(shortestpath)=>{\n\n        for(let i=0;i<shortestpath.length;i++){\n            setTimeout(() => {\n                document.getElementById(`node-${shortestpath[i].row}-${shortestpath[i].column}`).classList.add('shortest-path')\n\n            // after 10msec enabling all the button  \n            if(i===shortestpath.length-1){\n                setTimeout(()=>{\n                    FINISH=true  \n                    this.setState({is_running:false})\n                    RUNNING=false   \n                    \n                },10)\n            }\n\n            }, i*FINAL_PATH_ANIM_SPEED);\n            \n        }\n    }\n\n//==================================================================MAZES===========================================================\n//-------------------------------------------------------------RECURSSIVE Division------------------------------------\n\nvisualizeRecurssiveDivision=async()=>{\n    await this.clearGrid()\n    RUNNING=true\n    const {grid}=this.state   \n   let visitednodes=recursiveDivisionMaze(grid,2,ROW-1,2,COL-1,\"horizontal\",false,[])\n   this.animateRecurssiveDivision(visitednodes)\n\n}\n\n\n\n\n//-----------------------------------------Recurssive Division (Vertical skew and horizontal skew)--------------------\n\nvisualizeRecurssiveDivisionVertical=async()=>{\n    await this.clearGrid()\n    RUNNING=true\n    const {grid}=this.state   \n   let visitednodes=recurssiveVerticalSkew(grid,2,ROW-1,2,COL-1,\"vertical\",false,[])\n   this.animateRecurssiveDivision(visitednodes)\n\n}\n\nvisualizeRecurssiveDivisionHorizontal=async()=>{\n    await this.clearGrid()\n    RUNNING=true\n    const {grid}=this.state   \n   let visitednodes=recurssiveHorizontalSkew(grid,2,ROW-1,2,COL-1,\"horizontal\",false,[])\n   this.animateRecurssiveDivision(visitednodes)\n\n}\n\n\n\n//----------------------animate maze generation--------------------------------------\nanimateRecurssiveDivision=(visitedNodeInorder)=>{\n        \n    for(let i=0;i<visitedNodeInorder.length;i++){\n        visitedNodeInorder[i].isWall=true\n        setTimeout(() => {\n            \n            document.getElementById(`node-${visitedNodeInorder[i].row}-${visitedNodeInorder[i].column}`).classList.add('node-wall')\n\n            // after 10 msec enabling all the button  \n            if(i===visitedNodeInorder.length-1){\n                setTimeout(()=>{\n                    this.setState({is_running:false})\n                    RUNNING=false\n                },10)\n            }\n            \n        }, i*ANIMATION_SPEED);\n    }\n}\n\n//-------------------------------------------------------------RANDOM MAZE----------------------------------------------------------------\nvisualizeRandomMaze=async()=>{\n    await this.clearGrid()\n    const {grid}=this.state\n    let walls=randomMaze(grid)\n    for(let i=0;i<walls.length;i++){\n        walls[i].isWall=true\n        document.getElementById(`node-${walls[i].row}-${walls[i].column}`).classList.add('node-wall')\n    }\n    this.setState({is_running:false})\n}\n\n//-------------------------------------------------------------PRIM'S ALGO----------------------------------------------\nvisulizeprimsalgo=async ()=>{\n    await this.clearGrid()\n    RUNNING=true\n    const {grid}=this.state\n    // console.log(primsalgo(this.state.grid,grid[START_NODE_ROW][START_NODE_COL],grid[FINISH_NODE_ROW][FINISH_NODE_COL]))\n    let prims=primsalgo(this.state.grid,grid[START_NODE_ROW][START_NODE_COL],grid[FINISH_NODE_ROW][FINISH_NODE_COL])\n    await this.makewall(prims)\n    \n    setTimeout(()=>{\n        this.animatePrims(prims.removedWalls)\n    },50)\n       \n    \n}\n\nmakewall=(prims)=>{\n    for(let i=0;i<prims.addedWalls.length;i++){\n        document.getElementById(`node-${prims.addedWalls[i].row}-${prims.addedWalls[i].column}`).classList.add('node-wall')\n}\n}\n\nanimatePrims=(removedWalls)=>{\n        \n    for(let i=0;i<removedWalls.length;i++){\n        removedWalls[i].isWall=false\n        setTimeout(() => {\n            \n            document.getElementById(`node-${removedWalls[i].row}-${removedWalls[i].column}`).classList.remove('node-wall')\n\n            // after 10 msec enabling all the button  \n            if(i===removedWalls.length-1){\n                setTimeout(()=>{\n                    this.setState({is_running:false})\n                    RUNNING=false\n                },10)\n            }\n            \n        }, i*ANIMATION_SPEED);\n    }\n}\n\n\n\n\n\n\n//------------------------------------------------------------MOUSE EVENTS------------------------------------------------------------\n    //---------MOUSE DOWN----------\n\n    handleMouseDown(row, column,e) {\n        const {grid}=this.state\n        e.preventDefault();\n\n        //if any animation is running then disable the event listners\n        if(RUNNING) return\n\n        //if it is start nod then we want to move the start node on mouse enter (on mouse press)\n        if(grid[row][column].start){\n            START=true\n            MOUSE_PRESSED=true\n        }\n\n        //if it is start nod then we want to move the start node on mouse enter (on mouse press)\n        else if(grid[row][column].end){\n            END=true\n            MOUSE_PRESSED=true\n        }\n\n        //else toggle the wall\n        else{\n            getnewgridwithwallToggled(this.state.grid, row, column);\n            MOUSE_PRESSED=true\n        }\n    }\n\n    //------------MOUSE ENTER--------------\n\n     handleMouseEnter(row, column) {\n\n        //if any animation is running then disable the event listners\n        if(RUNNING) return\n        const {grid}= this.state\n        \n        //if mouse is not pressed on enter then return\n        if (!(MOUSE_PRESSED)) return;\n\n        //to fix the start and end node overlapping one another\n        if(grid[row][column].end) return;\n        if(grid[row][column].start)return;\n\n        //if entering with start node\n        if(START){\n            //wall return\n            if(grid[row][column].isWall) return\n\n            //remove start from previous \n            document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).classList.remove('node-start')\n            grid[START_NODE_ROW][START_NODE_COL].start=false\n\n            //assign new start \n            START_NODE_ROW=row\n            START_NODE_COL=column\n            document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).classList.add('node-start')\n          \n            //instant path IF animation is finished start Node\n            if(FINISH){\n                this.instantPathStart(row,column,CURRENT_ALGO)\n            }\n            return\n        }\n\n        //if entering with finish node\n        else if(END){\n            //wall\n            if(grid[row][column].isWall) return\n\n            //remove finish from previous\n            document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).classList.remove('node-end')\n            grid[FINISH_NODE_ROW][FINISH_NODE_COL].end=false\n\n            //assign new finish node\n            FINISH_NODE_ROW=row\n            FINISH_NODE_COL=column\n            document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).classList.add('node-end')\n\n             //instant path IF animation is finished finish Node\n            if(FINISH){\n                this.instantPathDestination(row,column,CURRENT_ALGO)\n            }\n            return\n        }\n\n        else{\n            getnewgridwithwallToggled(this.state.grid, row, column);\n        }\n      }\n    \n\n    //----Mouse Up-----\n    handleMouseUp() {\n        //if any animation is running then disable the event listners\n        if(RUNNING) return\n        const {grid}= this.state;\n       \n        //assign the final start node \n        if(START){ \n            grid[START_NODE_ROW][START_NODE_COL].start=true\n            grid[START_NODE_ROW][START_NODE_COL].isWall=false\n            START=false\n            MOUSE_PRESSED=false \n            return\n        }\n\n        //assign the final finish node\n        else if(END){\n            grid[FINISH_NODE_ROW][FINISH_NODE_COL].end=true\n            END=false\n            MOUSE_PRESSED=false \n            return\n        }     \n        MOUSE_PRESSED=false \n      }\n\n\n\n\n    //------------------------------------------------------------CLEAR PATH-------------------------------------------------------------\n\n    clearPath=()=>{\n        const {grid}=this.state\n        CURRENT_ALGO=\"\"\n        FINISH=false\n        let nodes=getallNodes(grid)\n        for(let node of nodes){\n            if(node.isWall) continue;\n             grid[node.row][node.column]=createNode(node.row,node.column)\n            document.getElementById(`node-${node.row}-${node.column}`).classList.remove('shortest-path')\n            document.getElementById(`node-${node.row}-${node.column}`).classList.remove('node-visited')\n        }\n\n    }\n\n\n\n\n\n\n//===================================================INSTANT PATH (WHEN WE MOVE START NODE)=============================\n\ninstantPathStart=(row,column,algorithm)=>{\n    const {grid}=this.state\n\n    if(algorithm===\"DIJKSTRA\"){\n        this.clearPath()\n        //bcz clear path clers the current algo and finsih\n        CURRENT_ALGO=\"DIJKSTRA\"\n        FINISH=true\n\n        //get the start node and finish node and animate without set timeout\n        let startNode=grid[row][column]\n        let finishNode=grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n        let visitednodes= dijkstra(grid,startNode,finishNode)\n        let shortestpath= getNodesInShortestPathOrder(finishNode)\n        for(let node of visitednodes){\n            document.getElementById(`node-${node.row}-${node.column}`).classList.add('node-visited')\n        }\n        for(let node of shortestpath){\n            document.getElementById(`node-${node.row}-${node.column}`).classList.add('shortest-path')\n        }\n    }\n\n\n    else if(algorithm===\"ASTAR\"){\n        this.clearPath()\n         //bcz clear path clers the current algo and finsih\n        CURRENT_ALGO=\"ASTAR\"\n        FINISH=true\n          //get the start node and finish node and animate without set timeout\n        let startNode=grid[row][column]\n        let finishNode=grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n        let visitednodes= astar(grid,startNode,finishNode)\n        let shortestpath= getNodesInShortestPathOrder(finishNode)\n        for(let node of visitednodes){\n            document.getElementById(`node-${node.row}-${node.column}`).classList.add('node-visited')\n        }\n        for(let node of shortestpath){\n            document.getElementById(`node-${node.row}-${node.column}`).classList.add('shortest-path')\n        }\n    }\n\n    else if(algorithm===\"DFS\"){\n        this.clearPath()\n        //bcz clear path clers the current algo and finsih\n        CURRENT_ALGO=\"DFS\"\n        FINISH=true\n        //get the start node and finish node and animate without set timeout\n        let startNode=grid[row][column]\n        let finishNode=grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n        let visitednodes= depthFirstSearch(grid,startNode,finishNode)\n        let shortestpath= getNodesInShortestPathOrder(finishNode)\n        for(let node of visitednodes){\n            document.getElementById(`node-${node.row}-${node.column}`).classList.add('node-visited')\n        }\n        for(let node of shortestpath){\n            document.getElementById(`node-${node.row}-${node.column}`).classList.add('shortest-path')\n        }\n    }\n\n    else if(algorithm===\"BFS\"){\n        this.clearPath()\n        //bcz clear path clers the current algo and finsih\n        CURRENT_ALGO=\"BFS\"\n        FINISH=true\n        //get the start node and finish node and animate without set timeout\n        let startNode=grid[row][column]\n        let finishNode=grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n        let visitednodes= breadthFirstSearch(grid,startNode,finishNode)\n        let shortestpath= getNodesInShortestPathOrder(finishNode)\n        for(let node of visitednodes){\n            document.getElementById(`node-${node.row}-${node.column}`).classList.add('node-visited')\n        }\n        for(let node of shortestpath){\n            document.getElementById(`node-${node.row}-${node.column}`).classList.add('shortest-path')\n        }\n    }\n}\n\n\n\n\n//===================================================INSTANT PATH (WHEN WE MOVE FINISH  NODE)=============================\n        \ninstantPathDestination=(row,column,algorithm)=>{\n        const {grid}=this.state\n        if(algorithm===\"DIJKSTRA\"){\n            this.clearPath()\n            //bcz clear path clears the current algo and finsih\n            CURRENT_ALGO=\"DIJKSTRA\"\n            FINISH=true\n            //get the start node and finish node and animate without set timeout\n            let startNode=grid[START_NODE_ROW][START_NODE_COL]\n            let finishNode=grid[row][column]\n            let visitednodes= dijkstra(grid,startNode,finishNode)\n            let shortestpath= getNodesInShortestPathOrder(finishNode)\n            for(let node of visitednodes){\n                document.getElementById(`node-${node.row}-${node.column}`).classList.add('node-visited')\n            }\n            for(let node of shortestpath){\n                document.getElementById(`node-${node.row}-${node.column}`).classList.add('shortest-path')\n            }\n        }\n\n\n        else if(algorithm===\"ASTAR\"){\n            this.clearPath()\n            //bcz clear path clears the current algo and finsih\n            CURRENT_ALGO=\"ASTAR\"\n            FINISH=true\n            let startNode=grid[START_NODE_ROW][START_NODE_COL]\n            let finishNode=grid[row][column]\n            let visitednodes= astar(grid,startNode,finishNode)\n            let shortestpath= getNodesInShortestPathOrder(finishNode)\n            for(let node of visitednodes){\n                document.getElementById(`node-${node.row}-${node.column}`).classList.add('node-visited')\n            }\n            for(let node of shortestpath){\n                document.getElementById(`node-${node.row}-${node.column}`).classList.add('shortest-path')\n            }\n        }\n\n        else if(algorithm===\"DFS\"){\n            this.clearPath()\n            //bcz clear path clears the current algo and finsih\n            CURRENT_ALGO=\"DFS\"\n            FINISH=true\n            //get the start node and finish node and animate without set timeout\n            let startNode=grid[START_NODE_ROW][START_NODE_COL]\n            let finishNode=grid[row][column]\n            let visitednodes= depthFirstSearch(grid,startNode,finishNode)\n            let shortestpath= getNodesInShortestPathOrder(finishNode)\n            for(let node of visitednodes){\n                document.getElementById(`node-${node.row}-${node.column}`).classList.add('node-visited')\n            }\n            for(let node of shortestpath){\n                document.getElementById(`node-${node.row}-${node.column}`).classList.add('shortest-path')\n            }\n        }\n\n        else if(algorithm===\"BFS\"){\n            this.clearPath()\n            //bcz clear path clears the current algo and finsih\n            CURRENT_ALGO=\"BFS\"\n            FINISH=true\n            //get the start node and finish node and animate without set timeout\n            let startNode=grid[START_NODE_ROW][START_NODE_COL]\n            let finishNode=grid[row][column]\n            let visitednodes= breadthFirstSearch(grid,startNode,finishNode)\n            let shortestpath= getNodesInShortestPathOrder(finishNode)\n            for(let node of visitednodes){\n                document.getElementById(`node-${node.row}-${node.column}`).classList.add('node-visited')\n            }\n            for(let node of shortestpath){\n                document.getElementById(`node-${node.row}-${node.column}`).classList.add('shortest-path')\n            }\n        }\n    }\n\n//handle tutorial\nhandleTut=()=>{\n    this.setState({load:false})\n}\n\n\n //===========================================================RENDER=======================================================================   \n    render() {\n\n        const {grid}=this.state\n        return (\n            <>\n                <NavBar \n                clearGrid={this.clearGrid}\n                clearPath={this.clearPath}\n                astar={this.visualizeAstar}\n                dijkstra={this.visualizeDijikstra}\n                bfs={this.visualizeBfs}\n                dfs={this.visualizeDfs}\n                recurDivMaze={this.visualizeRecurssiveDivision}\n                randomMaze={this.visualizeRandomMaze}\n                recurDivMazeVertical={this.visualizeRecurssiveDivisionVertical}\n                recurDivMazeHorizontal={this.visualizeRecurssiveDivisionHorizontal}\n                primsAlgo={this.visulizeprimsalgo}\n                is_running={this.state.is_running}\n                ></NavBar>\n                {/* <button onClick={this.visulizeprimsalgo}>prim</button> */}\n\n                <table id=\"grid\">\n                <tbody>\n                {this.state.load?<Tutorial handleTut={this.handleTut}></Tutorial>:null}\n                {grid.map((row,rowIdx)=>{\n                return  <tr key={rowIdx} id={rowIdx}>\n                        {row.map((node,nodeIdx)=>{\n                \n                            const {\n                                start,\n                                end,\n                                row,\n                                column,\n                                isVisited,\n                                isWall,\n                   }=node\n                            return <Node \n                            isStart={start}\n                            isEnd={end}\n                            row={row}\n                            column={column}\n                            isVisited={isVisited}\n                            isWall={isWall}\n                            onMouseDown={(row,column,e)=>{this.handleMouseDown(row,column,e)}}\n                            onMouseUp={()=>{this.handleMouseUp()}}\n                            onMouseEnter={(row,column)=>{this.handleMouseEnter(row,column)}}\n                            key={nodeIdx} \n                            ></Node>\n\n                        })}\n                    </tr>\n                })}\n                </tbody>\n                </table>\n                \n            </>\n        )\n    }\n}\n\nexport default PathfindingVisualizer\n\n\n\n\n//------------------------------------------------------INITALIZE GRID-------------------------------------------------\nconst initializeGrid=()=>{\n    let node=[]\n    for(let row=0;row<=ROW;row++){\n        let currentRow=[]\n        for(let column=0;column<=COL;column++){\n            currentRow.push(createNode(row,column))\n        }\n        node.push(currentRow)\n\n    }\n    return node\n}\n\n\n//------------------------------------------------------Node Properties----------------------------------------\nconst createNode=(row,column)=>{\n    return{\n        row,\n        column,\n        start:row===START_NODE_ROW && column===START_NODE_COL,\n        end:row===FINISH_NODE_ROW && column===FINISH_NODE_COL,\n        distance: Infinity,\n        isVisited: false,\n        isWall: false,\n        previousNode: null,\n        h:null,\n        f:null,\n    }\n}\n\n\n//---------------------------------------------------------------Wall TOggle Function----------------------------------------\nconst  getnewgridwithwallToggled=(grid,row,column)=>{\n\n    if(!(grid[row][column].start) && !(grid[row][column].end)){\n\n     grid[row][column].isWall=! grid[row][column].isWall\n\n     if(grid[row][column].isWall){\n        document.getElementById(`node-${row}-${column}`).classList.add('node-wall')\n    }\n    else{\n        document.getElementById(`node-${row}-${column}`).classList.remove('node-wall')\n    }\n\n    }\n    \n\n   \n\n}","import React from 'react';\nimport PathfindingVisualizer from './Components/PathfindingVisualizer/PathfindingVisualizer';\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}